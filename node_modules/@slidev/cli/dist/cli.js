"use strict"; function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { newObj[key] = obj[key]; } } } newObj.default = obj; return newObj; } } function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }










var _chunkCUQDKJBBjs = require('./chunk-CUQDKJBB.js');



var _chunkTXDYSJOBjs = require('./chunk-TXDYSJOB.js');




var _chunkOVFYMGU6js = require('./chunk-OVFYMGU6.js');

// node/cli.ts
_chunkOVFYMGU6js.init_cjs_shims.call(void 0, );
var import_fast_deep_equal = _chunkOVFYMGU6js.__toESM.call(void 0, _chunkTXDYSJOBjs.require_fast_deep_equal.call(void 0, ));
var _path = require('path'); var _path2 = _interopRequireDefault(_path);
var _net = require('net'); var _net2 = _interopRequireDefault(_net);
var _os = require('os'); var _os2 = _interopRequireDefault(_os);
var _child_process = require('child_process');
var _readline = require('readline'); var readline = _interopRequireWildcard(_readline);
var _fsextra = require('fs-extra'); var _fsextra2 = _interopRequireDefault(_fsextra);
var _open = require('open'); var _open2 = _interopRequireDefault(_open);
var _yargs = require('yargs'); var _yargs2 = _interopRequireDefault(_yargs);
var _prompts = require('prompts'); var _prompts2 = _interopRequireDefault(_prompts);
var _kolorist = require('kolorist');
var _isinstalledglobally = require('is-installed-globally'); var _isinstalledglobally2 = _interopRequireDefault(_isinstalledglobally);
var _parser = require('@slidev/parser');
var _fs = require('@slidev/parser/fs');
var CONFIG_RESTART_FIELDS = [
  "highlighter",
  "monaco",
  "routerMode",
  "fonts",
  "css"
];
_fs.injectPreparserExtensionLoader.call(void 0, async (headmatter, filepath) => {
  var _a;
  const addons = (_a = headmatter == null ? void 0 : headmatter.addons) != null ? _a : [];
  const roots = [
    _chunkCUQDKJBBjs.getUserRoot.call(void 0, {}).userRoot,
    ..._chunkCUQDKJBBjs.getAddonRoots.call(void 0, addons, ""),
    _chunkCUQDKJBBjs.getClientRoot.call(void 0, )
  ];
  const mergeArrays = (a, b) => a.concat(b);
  return await _chunkTXDYSJOBjs.loadSetups.call(void 0, roots, "preparser.ts", { filepath, headmatter }, [], false, mergeArrays);
});
var cli = _yargs2.default.scriptName("slidev").usage("$0 [args]").version(_chunkCUQDKJBBjs.version).strict().showHelpOnFail(false).alias("h", "help").alias("v", "version");
cli.command(
  "* [entry]",
  "Start a local server for Slidev",
  (args) => commonOptions(args).option("port", {
    alias: "p",
    type: "number",
    describe: "port"
  }).option("open", {
    alias: "o",
    default: false,
    type: "boolean",
    describe: "open in browser"
  }).option("remote", {
    type: "string",
    describe: "listen public host and enable remote control"
  }).option("log", {
    default: "warn",
    type: "string",
    choices: ["error", "warn", "info", "silent"],
    describe: "log level"
  }).option("inspect", {
    default: false,
    type: "boolean",
    describe: "enable the inspect plugin for debugging"
  }).option("force", {
    alias: "f",
    default: false,
    type: "boolean",
    describe: "force the optimizer to ignore the cache and re-bundle  "
  }).strict().help(),
  async ({ entry, theme, port: userPort, open, log, remote, force, inspect }) => {
    if (!_fsextra2.default.existsSync(entry) && !entry.endsWith(".md"))
      entry = `${entry}.md`;
    if (!_fsextra2.default.existsSync(entry)) {
      const { create } = await _prompts2.default.call(void 0, {
        name: "create",
        type: "confirm",
        initial: "Y",
        message: `Entry file ${_kolorist.yellow.call(void 0, `"${entry}"`)} does not exist, do you want to create it?`
      });
      if (create)
        await _fsextra2.default.copyFile(_path2.default.resolve(__dirname, "../template.md"), entry);
      else
        process.exit(0);
    }
    let server;
    let port = 3030;
    async function initServer() {
      if (server)
        await server.close();
      const options = await _chunkCUQDKJBBjs.resolveOptions.call(void 0, { entry, remote, theme, inspect }, "dev");
      port = userPort || await findFreePort(3030);
      server = await _chunkCUQDKJBBjs.createServer.call(void 0, 
        options,
        {
          server: {
            port,
            strictPort: true,
            open,
            host: remote !== void 0 ? "0.0.0.0" : "localhost",
            force
          },
          logLevel: log
        },
        {
          onDataReload(newData, data) {
            if (!theme && _chunkCUQDKJBBjs.resolveThemeName.call(void 0, newData.config.theme) !== _chunkCUQDKJBBjs.resolveThemeName.call(void 0, data.config.theme)) {
              console.log(_kolorist.yellow.call(void 0, "\n  restarting on theme change\n"));
              initServer();
            } else if (CONFIG_RESTART_FIELDS.some((i) => !(0, import_fast_deep_equal.default)(newData.config[i], data.config[i]))) {
              console.log(_kolorist.yellow.call(void 0, "\n  restarting on config change\n"));
              initServer();
            }
          }
        }
      );
      await server.listen();
      printInfo(options, port, remote);
    }
    const SHORTCUTS = [
      {
        name: "r",
        fullname: "restart",
        action() {
          initServer();
        }
      },
      {
        name: "o",
        fullname: "open",
        action() {
          _open2.default.call(void 0, `http://localhost:${port}`);
        }
      },
      {
        name: "e",
        fullname: "edit",
        action() {
          _child_process.exec.call(void 0, `code "${entry}"`);
        }
      }
    ];
    function bindShortcut() {
      process.stdin.resume();
      process.stdin.setEncoding("utf8");
      readline.emitKeypressEvents(process.stdin);
      if (process.stdin.isTTY)
        process.stdin.setRawMode(true);
      process.stdin.on("keypress", (str, key) => {
        if (key.ctrl && key.name === "c") {
          process.exit();
        } else {
          const [sh] = SHORTCUTS.filter((item) => item.name === str);
          if (sh) {
            try {
              sh.action();
            } catch (err) {
              console.error(`Failed to execute shortcut ${sh.fullname}`, err);
            }
          }
        }
      });
    }
    initServer();
    bindShortcut();
  }
);
cli.command(
  "build [entry]",
  "Build hostable SPA",
  (args) => commonOptions(args).option("watch", {
    alias: "w",
    default: false,
    describe: "build watch"
  }).option("out", {
    alias: "o",
    type: "string",
    default: "dist",
    describe: "output dir"
  }).option("base", {
    type: "string",
    describe: "output base"
  }).option("download", {
    alias: "d",
    type: "boolean",
    describe: "allow download as PDF"
  }).option("inspect", {
    default: false,
    type: "boolean",
    describe: "enable the inspect plugin for debugging"
  }).strict().help(),
  async ({ entry, theme, watch, base, download, out, inspect }) => {
    const { build } = await Promise.resolve().then(() => _chunkOVFYMGU6js.__toESM.call(void 0, _chunkOVFYMGU6js.__require.call(void 0, "./build-ATIWLFVV.js")));
    const options = await _chunkCUQDKJBBjs.resolveOptions.call(void 0, { entry, theme, inspect }, "build");
    if (download && !options.data.config.download)
      options.data.config.download = download;
    printInfo(options);
    await build(options, {
      base,
      build: {
        watch: watch ? {} : void 0,
        outDir: out
      }
    });
  }
);
cli.command(
  "format [entry]",
  "Format the markdown file",
  (args) => commonOptions(args).strict().help(),
  async ({ entry }) => {
    const data = await _chunkCUQDKJBBjs.parser.load(entry);
    _chunkCUQDKJBBjs.parser.prettify(data);
    await _chunkCUQDKJBBjs.parser.save(data);
  }
);
cli.command(
  "theme [subcommand]",
  "Theme related operations",
  (command) => {
    return command.command(
      "eject",
      "Eject current theme into local file system",
      (args) => commonOptions(args).option("dir", {
        type: "string",
        default: "theme"
      }),
      async ({ entry, dir, theme: themeInput }) => {
        const data = await _chunkCUQDKJBBjs.parser.load(entry);
        const theme = _chunkCUQDKJBBjs.resolveThemeName.call(void 0, themeInput || data.config.theme);
        if (theme === "none") {
          console.error('Cannot eject theme "none"');
          process.exit(1);
        }
        if (_chunkCUQDKJBBjs.isPath.call(void 0, theme)) {
          console.error("Theme is already ejected");
          process.exit(1);
        }
        const roots = _chunkCUQDKJBBjs.getThemeRoots.call(void 0, theme, entry);
        if (!roots.length) {
          console.error(`Could not find theme "${theme}"`);
          process.exit(1);
        }
        const root = roots[0];
        await _fsextra2.default.copy(root, _path2.default.resolve(dir), {
          filter: (i) => !/node_modules|.git/.test(_path2.default.relative(root, i))
        });
        const dirPath = `./${dir}`;
        data.slides[0].frontmatter.theme = dirPath;
        data.slides[0].raw = null;
        await _chunkCUQDKJBBjs.parser.save(data);
        console.log(`Theme "${theme}" ejected successfully to "${dirPath}"`);
      }
    );
  },
  () => {
    cli.showHelp();
    process.exit(1);
  }
);
cli.command(
  "export [entry]",
  "Export slides to PDF",
  (args) => commonOptions(args).option("output", {
    type: "string",
    describe: "path to the output"
  }).option("format", {
    default: "pdf",
    type: "string",
    choices: ["pdf", "png", "md"],
    describe: "output format"
  }).option("timeout", {
    default: 3e4,
    type: "number",
    describe: "timeout for rendering the print page"
  }).option("range", {
    type: "string",
    describe: 'page ranges to export, for example "1,4-5,6"'
  }).option("dark", {
    default: false,
    type: "boolean",
    describe: "export as dark theme"
  }).option("with-clicks", {
    alias: "c",
    default: false,
    type: "boolean",
    describe: "export pages for every clicks"
  }).option("executable-path", {
    type: "string",
    describe: "executable to override playwright bundled browser"
  }).option("with-toc", {
    default: false,
    type: "boolean",
    describe: "export pages with outline"
  }).strict().help(),
  async ({
    entry,
    theme,
    output,
    format,
    timeout,
    range,
    dark,
    "with-clicks": withClicks,
    "executable-path": executablePath,
    "with-toc": withTOC
  }) => {
    process.env.NODE_ENV = "production";
    const { exportSlides } = await Promise.resolve().then(() => _chunkOVFYMGU6js.__toESM.call(void 0, _chunkOVFYMGU6js.__require.call(void 0, "./export-OIZT2CQS.js")));
    const port = await findFreePort(12445);
    const options = await _chunkCUQDKJBBjs.resolveOptions.call(void 0, { entry, theme }, "export");
    output = output || options.data.config.exportFilename || `${_path2.default.basename(entry, ".md")}-export`;
    const server = await _chunkCUQDKJBBjs.createServer.call(void 0, 
      options,
      {
        server: { port },
        clearScreen: false
      }
    );
    await server.listen(port);
    printInfo(options);
    _chunkCUQDKJBBjs.parser.filterDisabled(options.data);
    const width = options.data.config.canvasWidth;
    const height = Math.round(width / options.data.config.aspectRatio);
    output = await exportSlides({
      port,
      slides: options.data.slides,
      total: options.data.slides.length,
      range,
      format,
      output,
      timeout,
      dark,
      routerMode: options.data.config.routerMode,
      width,
      height,
      withClicks,
      executablePath,
      withTOC
    });
    console.log(`${_kolorist.green.call(void 0, "  \u2713 ")}${_kolorist.dim.call(void 0, "exported to ")}./${output}
`);
    server.close();
    process.exit(0);
  }
);
cli.command(
  "export-notes [entry]",
  "Export slide notes to PDF",
  (args) => args.positional("entry", {
    default: "slides.md",
    type: "string",
    describe: "path to the slides markdown entry"
  }).option("output", {
    type: "string",
    describe: "path to the output"
  }).option("timeout", {
    default: 3e4,
    type: "number",
    describe: "timeout for rendering the print page"
  }).strict().help(),
  async ({
    entry,
    output,
    timeout
  }) => {
    process.env.NODE_ENV = "production";
    const { exportNotes } = await Promise.resolve().then(() => _chunkOVFYMGU6js.__toESM.call(void 0, _chunkOVFYMGU6js.__require.call(void 0, "./export-OIZT2CQS.js")));
    const port = await findFreePort(12445);
    const options = await _chunkCUQDKJBBjs.resolveOptions.call(void 0, { entry }, "export");
    if (!output)
      output = options.data.config.exportFilename ? `${options.data.config.exportFilename}-notes` : `${_path2.default.basename(entry, ".md")}-export-notes`;
    const server = await _chunkCUQDKJBBjs.createServer.call(void 0, 
      options,
      {
        server: { port },
        clearScreen: false
      }
    );
    await server.listen(port);
    printInfo(options);
    _chunkCUQDKJBBjs.parser.filterDisabled(options.data);
    output = await exportNotes({
      port,
      output,
      timeout
    });
    console.log(`${_kolorist.green.call(void 0, "  \u2713 ")}${_kolorist.dim.call(void 0, "exported to ")}./${output}
`);
    server.close();
    process.exit(0);
  }
);
cli.help().parse();
function commonOptions(args) {
  return args.positional("entry", {
    default: "slides.md",
    type: "string",
    describe: "path to the slides markdown entry"
  }).option("theme", {
    alias: "t",
    type: "string",
    describe: "override theme"
  });
}
function printInfo(options, port, remote) {
  console.log();
  console.log();
  console.log(`  ${_kolorist.cyan.call(void 0, "\u25CF") + _kolorist.blue.call(void 0, "\u25A0") + _kolorist.yellow.call(void 0, "\u25B2")}`);
  console.log(`${_kolorist.bold.call(void 0, "  Slidev")}  ${_kolorist.blue.call(void 0, `v${_chunkCUQDKJBBjs.version}`)} ${_isinstalledglobally2.default ? _kolorist.yellow.call(void 0, "(global)") : ""}`);
  console.log();
  console.log(_kolorist.dim.call(void 0, "  theme   ") + (options.theme ? _kolorist.green.call(void 0, options.theme) : _kolorist.gray.call(void 0, "none")));
  console.log(_kolorist.dim.call(void 0, "  entry   ") + _kolorist.dim.call(void 0, _path2.default.dirname(options.entry) + _path2.default.sep) + _path2.default.basename(options.entry));
  if (port) {
    const query = remote ? `?password=${remote}` : "";
    const presenterPath = `${options.data.config.routerMode === "hash" ? "/#/" : "/"}presenter/${query}`;
    console.log();
    console.log(`${_kolorist.dim.call(void 0, "  public slide show ")}  > ${_kolorist.cyan.call(void 0, `http://localhost:${_kolorist.bold.call(void 0, port)}/`)}`);
    if (query)
      console.log(`${_kolorist.dim.call(void 0, "  private slide show ")} > ${_kolorist.cyan.call(void 0, `http://localhost:${_kolorist.bold.call(void 0, port)}/${query}`)}`);
    console.log(`${_kolorist.dim.call(void 0, "  presenter mode ")}     > ${_kolorist.blue.call(void 0, `http://localhost:${_kolorist.bold.call(void 0, port)}${presenterPath}`)}`);
    if (options.inspect)
      console.log(`${_kolorist.dim.call(void 0, "  inspector")}           > ${_kolorist.yellow.call(void 0, `http://localhost:${_kolorist.bold.call(void 0, port)}/__inspect/`)}`);
    if (remote !== void 0) {
      Object.values(_os2.default.networkInterfaces()).forEach(
        (v) => (v || []).filter((details) => String(details.family).slice(-1) === "4" && !details.address.includes("127.0.0.1")).forEach(({ address }) => {
          console.log(`${_kolorist.dim.call(void 0, "  remote control ")}     > ${_kolorist.blue.call(void 0, `http://${address}:${port}${presenterPath}`)}`);
        })
      );
    } else {
      console.log(`${_kolorist.dim.call(void 0, "  remote control ")}     > ${_kolorist.dim.call(void 0, "pass --remote to enable")}`);
    }
    console.log();
    console.log(`${_kolorist.dim.call(void 0, "  shortcuts ")}          > ${_kolorist.underline.call(void 0, "r")}${_kolorist.dim.call(void 0, "estart | ")}${_kolorist.underline.call(void 0, "o")}${_kolorist.dim.call(void 0, "pen | ")}${_kolorist.underline.call(void 0, "e")}${_kolorist.dim.call(void 0, "dit")}`);
  }
  console.log();
  _parser.verifyConfig.call(void 0, options.data.config, options.data.themeMeta, (v) => console.warn(_kolorist.yellow.call(void 0, `  ! ${v}`)));
  console.log();
}
function isPortFree(port) {
  return new Promise((resolve) => {
    const server = _net2.default.createServer((socket) => {
      socket.write("Echo server\r\n");
      socket.pipe(socket);
    });
    server.listen(port, "127.0.0.1");
    server.on("error", () => {
      resolve(false);
    });
    server.on("listening", () => {
      server.close();
      resolve(true);
    });
  });
}
async function findFreePort(start) {
  if (await isPortFree(start))
    return start;
  return findFreePort(start + 1);
}
